---
layout: post
title: "ssh 反向隧道 实现内网穿透"
date: 2019-03-16 18:16:49 +0800
category: linux
tags: [linux]
---
* content
{:toc}

# 1. 环境

设备|IP|备注
|---|---|---|
|A|192.168.8.2|内网主机|
|B|123.59.101.99|外网主机，用于跳转|

**目的:**

外网 通过连接 `B` 主机的 `1234` 端口 连接到 `A` 主机的 `22` 端口

**解决方法：**

在 `A` 主机 上做 `B` 主机的反向代理

在`B` 主机上做正想代理

# 2. 操作

## 2.1 命令解释

- 返现代理

	```
	ssh -fCNR
	```

- 正向代理

	```
	ssh -fCNL
	```
	
- 参数解释

	```
	-f 后台执行ssh 指令
	-C 允许压缩数据
	-N 不执行远程指令
	-R 将远程主机（服务器）的某个短裤转发到本地短裤指定机器的指定端口
	-L 将本地机器（客户机）的某个短裤转发到远端指定机器的指定端口
	-p 指定远程主机的端口
	```
	
## 2.2. 操作步骤

1. 建立A机器到B机器的反向代理，具体指令为

	`ssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器端口] [登陆B机器的用户名@服务器IP]`
	
	在这里我使用了B机器的7280端口，以及A机器的22端口，按照上面的指令就是这样子的操作
	
	```
	ssh -fCNR 7280:localhost:22 root@123.59.101.99
	```
	
	检验是否已经启动了可以使用ps aux | grep ssh指令来查看：
	
	```
	ps aux|grep ssh
	```
	
2. 建立B机器的正向代理，用来做转发，具体指令为

	`ssh -fCNL [A机器IP或省略]:[A机器端口]:[B机器的IP]:[B机器端口] [登陆B机器的用户名@B机器的IP]`
	
	按照第3那里输入的指令，这里的B机器的端口和上面的B机器的端口是一致的，端口1234的也是B机器的。
	
	```
	ssh -fCNL *:1234:localhost:7280 localhost
	```
	
	检验是否已经启动了可以使用ps aux | grep ssh指令来查看：

	```
	ps aux|grep ssh
	```
	
	在此1234端口为本地转发端口，负责和外网进行通信，并将数据转发的7280这个端口，实现了可以从其他机器访问的功能。同时，*号表示可以接受任何IP的访问。

3. 测试

	`ssh -p1234 root@123.59.101.99`
	
	输入密码后，查看是否已经连上主机 A
	
# 3. 更优雅的操作

不幸的是这种ssh反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持了，为此我们需要另外的方法来提供稳定的ssh反向代理隧道。

- 密钥登陆

	ssh-copy-id 外网用户名@外网IP
	
	```
	ssh-copy-id root@123.59.101.99
	```
	
- 使用`autossh`建立更稳定的隧道

	```
	# 安装autossh
	yum -y install autossh
	
	autossh -M 7281 -fCNR 7280:localhost:22 root@123.59.101.99
	```
	
	autossh的参数与ssh的参数是一致的，但是不同的是，在隧道断开的时候，autossh会自动重新连接而ssh不会。另外不同的是我们需要指出的-M参数，这个参数指定一个端口，这个端口是外网的B机器用来接收内网A机器的信息，如果隧道不正常而返回给A机器让他实现重新连接。
	
- 配置开机启动

	```
	vi /etc/rc.d/rc.local
	
	#添加内容
	autossh -M 7281 -fCNR 7280:localhost:22 root@123.59.101.99
	
	#添加执行权限
	chmod +x /etc/rc.d/rc.local

	```
	
	
	